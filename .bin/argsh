#!/usr/bin/env bash
# shellcheck disable=SC1091 disable=SC2034 disable=SC2046 disable=SC2120
set -euo pipefail

: "${PATH_BASE:="$(git rev-parse --show-toplevel)"}"
: "${MIN_COVERAGE:="70"}"
:

source "${PATH_BASE}/libraries/args.sh"
source "${PATH_BASE}/libraries/args.utils.sh"
source "${PATH_BASE}/libraries/binary.sh"
source "${PATH_BASE}/libraries/docker.sh"
# trap error::stacktrace EXIT

###
### docs
###
test::docs() {
  :args "Run tests for the documentation" "${@}"
  docker run --rm $(docker::user) node:21-alpine sh -c "
    cd /workspace/www
    [ -d node_modules ] || yarn --silent --frozen-lockfile
    yarn build
  "
}

lint::docs() {
  :args "Run linters for the documentation" "${@}"
  docker run --rm $(docker::user) node:21-alpine sh -c "
    cd /workspace/www
    [ -d node_modules ] || yarn --silent --frozen-lockfile
    yarn lint:content
    yarn lint
  "
}

lint::vale() {
  :args "Run vale for the documentation" "${@}"
  local alert_level="${vale?"need to specify alert level"}"
  binary::exists docker || exit 1
  docker run --rm $(docker::user) jdkato/vale:latest sh -c "
    cd /workspace/www/vale
    ./run-vale.sh docs content \"${alert_level}\"
  "
}

###
### argsh
###
generate::docs() {
  :args "Generate library documentation for docs" "${@}"
  argsh::main docs libraries www/apps/docs/content/libraries
}

minify::argsh() {
  :args "Minify argsh libraries" "${@}"
  argsh::main minify libraries -t argsh.min.tmpl -o argsh.min.sh
}

coverage::argsh() {
  :args "Generate coverage report for argsh (bash + builtin)" "${@}"
  argsh::main coverage libraries -o coverage --min "${MIN_COVERAGE}"
  # Also generate builtin coverage if Rust toolchain is available
  if binary::exists cargo; then
    echo ""
    echo "── Builtin (Rust) coverage ──"
    coverage::builtin
  fi
}

test::argsh() {
  local test_minify
  local -a args=(
    'test-minify|m:+' "Run tests for argsh.min.sh"
  )
  :args "Run tests for the arg.sh library" "${@}"
  ! (( test_minify )) || {
    BATS_LOAD="argsh.min.sh"
    export BATS_LOAD
  }
  argsh::main test libraries .docker/test
}

lint::argsh() {
  local test_minify
  local -a args=(
    'test-minify|m:+' "Run tests for argsh.min.sh"
  )
  :args "Run linters for the arg.sh library" "${@}"
  if (( test_minify )); then
    argsh::main lint argsh.min.sh
  else
    argsh::main lint libraries
  fi
}

argsh::docker() {
  local tag="latest"
  local -a args=(
    'tag|t' "Docker image tag"
  )
  :args "Build docker image for argsh" "${@}"
  docker build -t "ghcr.io/arg-sh/argsh:${tag}" -f "${PATH_BASE}/Dockerfile" "${PATH_BASE}"
}

###
### builtin (Rust native builtins)
###
_require_rust() {
  binary::exists cargo || {
    echo "Rust toolchain required. Install: https://rustup.rs"
    return 1
  } >&2
}

lint::builtin() {
  :args "Run clippy on native builtins" "${@}"
  _require_rust
  cargo clippy --release \
    --manifest-path "${PATH_BASE}/builtin/Cargo.toml" \
    -- -D warnings
}

test::builtin() {
  :args "Build and test native builtins" "${@}"
  _require_rust
  cargo build --release \
    --manifest-path "${PATH_BASE}/builtin/Cargo.toml"
  cp "${PATH_BASE}/builtin/target/release/libargsh.so" "${PATH_BIN}/argsh.so"
  binary::exists bats || {
    echo "bats required. Install: https://github.com/bats-core/bats-core"
    return 1
  } >&2
  ARGSH_BUILTIN_TEST=1 ARGSH_SOURCE=argsh \
    bats "${PATH_BASE}/libraries/args.bats"
}

coverage::builtin() {
  :args "Generate coverage for native builtins" "${@}"
  _require_rust
  binary::exists bats || {
    echo "bats required. Install: https://github.com/bats-core/bats-core"
    return 1
  } >&2

  local host_triple llvm_tools cov_dir so_path
  host_triple="$(rustc -vV | awk '/host:/{print $2}')"
  llvm_tools="$(rustc --print sysroot)/lib/rustlib/${host_triple}/bin"
  cov_dir="${PATH_BASE}/builtin/target/coverage"
  so_path="${PATH_BASE}/builtin/target/release/libargsh.so"

  # Ensure llvm-tools
  [[ -x "${llvm_tools}/llvm-profdata" ]] || {
    echo "Installing llvm-tools..."
    rustup component add llvm-tools
  }

  # Build with coverage instrumentation (override release profile settings that break coverage)
  echo "Building with coverage instrumentation..."
  RUSTFLAGS="-C instrument-coverage" \
  CARGO_PROFILE_RELEASE_STRIP="none" \
  CARGO_PROFILE_RELEASE_LTO="false" \
  CARGO_PROFILE_RELEASE_PANIC="unwind" \
    cargo build --release \
      --manifest-path "${PATH_BASE}/builtin/Cargo.toml"

  cp "${so_path}" "${PATH_BIN}/argsh.so"
  rm -rf "${cov_dir}"
  mkdir -p "${cov_dir}"

  echo "Running tests..."
  LLVM_PROFILE_FILE="${cov_dir}/coverage-%p-%m.profraw" \
  ARGSH_BUILTIN_TEST=1 ARGSH_SOURCE=argsh \
    bats "${PATH_BASE}/libraries/args.bats"

  # Merge profile data
  "${llvm_tools}/llvm-profdata" merge -sparse \
    "${cov_dir}"/coverage-*.profraw \
    -o "${cov_dir}/coverage.profdata"

  echo ""
  "${llvm_tools}/llvm-cov" report \
    --instr-profile="${cov_dir}/coverage.profdata" \
    "${so_path}" \
    --ignore-filename-regex='\.cargo/registry'

  # Export JSON and generate builtin/coverage.json
  "${llvm_tools}/llvm-cov" export \
    --instr-profile="${cov_dir}/coverage.profdata" \
    "${so_path}" \
    --ignore-filename-regex='\.cargo/registry' \
    --summary-only | python3 -c "
import json, sys, datetime
data = json.load(sys.stdin)
totals = data['data'][0]['totals']['lines']
files = []
for f in data['data'][0]['files']:
    s = f['summary']['lines']
    files.append({
        'file': f['filename'],
        'percent_covered': f'{s[\"percent\"]:.2f}',
        'covered_lines': str(s['covered']),
        'total_lines': str(s['count'])
    })
result = {
    'files': sorted(files, key=lambda x: float(x['percent_covered']), reverse=True),
    'percent_covered': f'{totals[\"percent\"]:.2f}',
    'covered_lines': totals['covered'],
    'total_lines': totals['count'],
    'percent_low': 25,
    'percent_high': 75,
    'command': 'bats+llvm-cov',
    'date': datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
}
json.dump(result, sys.stdout, indent=2)
print()
" > "${PATH_BASE}/builtin/coverage.json"

  local pct
  pct="$(python3 -c "import json; print(json.load(open('${PATH_BASE}/builtin/coverage.json'))['percent_covered'])")"
  echo ""
  echo "Coverage: ${pct}% of required ${MIN_COVERAGE}%"

  # Rebuild without instrumentation for normal use
  echo "Rebuilding without instrumentation..."
  cargo build --release \
    --manifest-path "${PATH_BASE}/builtin/Cargo.toml"
  cp "${so_path}" "${PATH_BIN}/argsh.so"
}

###
### main
###
argsh::main() {
  local tty=""
  argsh::docker &>/dev/null

  [[ ! -t 1 ]] || tty="-it"
  # shellcheck disable=SC2046
  docker run --rm ${tty} $(docker::user) -w /workspace \
    -e "BATS_LOAD" \
    -e "ARGSH_SOURCE" \
    -e "GIT_COMMIT_SHA=$(git rev-parse HEAD 2>/dev/null || :)" \
    -e "GIT_VERSION=$(git describe --tags --dirty 2>/dev/null || :)" \
    ghcr.io/arg-sh/argsh:latest "${@}" 
}

_main() {
  if [[ "${BASH_SOURCE[-1]}" != "${1:-}" && -f "${1:-}" ]]; then
    ARGSH_SOURCE="${1}"; shift
    # shellcheck source=/dev/null
    . "${ARGSH_SOURCE}"
    exit 0
  fi

  binary::exists docker || {
    echo "This script requires Docker to be installed"
    return 1
  } >&2

  local -a usage
  usage=(
    -                           "Commands argsh"
    'coverage:-coverage::argsh' "Generate coverage"
    'lint:-lint::argsh'         "Run linters"
    'test:-test::argsh'         "Run tests"
    'minify:-minify::argsh'     "Minify argsh libraries"
    -                           "Commands documentation"
    'generate:-generate::docs'  "Generate argsh library documentation"
    'docs-lint:-lint::docs'     "Run linters"
    'docs-test:-test::docs'     "Run tests"
    'vale:-lint::vale'          "Run vale tests"
    -                           "Commands builtin (Rust)"
    'builtin-lint:-lint::builtin'         "Run clippy"
    'builtin-test:-test::builtin'         "Build and test"
    'builtin-coverage:-coverage::builtin' "Generate coverage"
    -                           "Additional commands"
    'docker:-argsh::docker'     "Build docker image"
  )
  :usage "Helper to manage this project" "${@}"
  "${usage[@]}"
}

[[ "${BASH_SOURCE[0]}" != "${0}" ]] || _main "${@}"