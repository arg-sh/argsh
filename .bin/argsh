#!/usr/bin/env bash
# shellcheck disable=SC1091 disable=SC2034 disable=SC2046 disable=SC2120
set -euo pipefail

: "${PATH_BASE:="$(git rev-parse --show-toplevel)"}"
: "${PATH_BIN:="${PATH_BASE}/.bin"}"
: "${ARGSH_SOURCE:="argsh"}"; export ARGSH_SOURCE
: "${MIN_COVERAGE:="70"}"

source "${PATH_BASE}/libraries/args.sh"
source "${PATH_BASE}/libraries/args.utils.sh"
source "${PATH_BASE}/libraries/binary.sh"
source "${PATH_BASE}/libraries/docker.sh"
# trap error::stacktrace EXIT

###
### docs
###
test::docs() {
  :args "Run tests for the documentation" "${@}"
  docker run --rm $(docker::user) node:21-alpine sh -c "
    cd /workspace/www
    [ -d node_modules ] || yarn --silent --frozen-lockfile
    yarn build
  "
}

lint::docs() {
  :args "Run linters for the documentation" "${@}"
  docker run --rm $(docker::user) node:21-alpine sh -c "
    cd /workspace/www
    [ -d node_modules ] || yarn --silent --frozen-lockfile
    yarn lint:content
    yarn lint
  "
}

lint::vale() {
  local alert_level
  local -a args=(
    'alert_level' "Alert level for vale (error, warning, suggestion)"
  )
  :args "Run vale for the documentation" "${@}"
  binary::exists docker || exit 1
  docker run --rm $(docker::user) jdkato/vale:latest sh -c "
    cd /workspace/www/vale
    ./run-vale.sh docs content \"${alert_level}\"
  "
}

###
### argsh
###
generate::docs() {
  :args "Generate library documentation for docs" "${@}"
  argsh::main docs "libraries/*.sh builtin/src/to.rs builtin/src/is.rs builtin/src/args.rs builtin/src/field.rs builtin/src/import.rs builtin/src/usage/mod.rs builtin/src/usage/completion.rs builtin/src/usage/docgen.rs builtin/src/usage/mcp.rs" www/apps/docs/content/libraries
}

minify::argsh() {
  :args "Minify argsh libraries" "${@}"
  argsh::main minify libraries -t argsh.min.tmpl -o argsh.min.sh
}

test::argsh() {
  local test_minify
  local -a args=(
    'test-minify|m:+' "Run tests for argsh.min.sh"
  )
  :args "Run tests for the arg.sh library" "${@}"
  ! (( test_minify )) || {
    BATS_LOAD="argsh.min.sh"
    export BATS_LOAD
  }
  argsh::main test libraries .docker/test
}

_test() {
  local target="all"
  local test_minify
  local -a args=(
    'test-minify|m:+' "Run tests for argsh.min.sh"
    'target' "Test target (all, argsh, builtin, minifier, shdoc)"
  )
  :args "Run tests" "${@}"
  ! (( test_minify )) || {
    BATS_LOAD="argsh.min.sh"
    export BATS_LOAD
  }

  case "${target}" in
    all)
      ARGSH_BUILTIN_TEST=1 \
        argsh::main test libraries .docker/test
      if command -v cargo &>/dev/null; then
        test::minifier
        test::shdoc
      fi
      ;;
    argsh)    argsh::main test libraries .docker/test ;;
    builtin)
      ARGSH_BUILTIN_TEST=1 \
        argsh::main test libraries .docker/test
      ;;
    minifier) test::minifier ;;
    shdoc)    test::shdoc ;;
    *)
      echo "Unknown target: ${target}. Use: all, argsh, builtin, minifier, shdoc" >&2
      return 1
      ;;
  esac
}

lint::argsh() {
  local test_minify
  local -a args=(
    'test-minify|m:+' "Run tests for argsh.min.sh"
  )
  :args "Run linters for the arg.sh library" "${@}"
  if (( test_minify )); then
    argsh::main lint argsh.min.sh
  else
    argsh::main lint libraries
  fi
}

_lint() {
  local target="all"
  local test_minify
  local -a args=(
    'test-minify|m:+' "Lint argsh.min.sh"
    'target' "Lint target (all, argsh, builtin, minifier, shdoc)"
  )
  :args "Run linters" "${@}"
  case "${target}" in
    all)
      if (( test_minify )); then
        argsh::main lint argsh.min.sh
      else
        argsh::main lint libraries
      fi
      if command -v cargo &>/dev/null; then
        lint::builtin
        lint::minifier
        lint::shdoc
      fi
      ;;
    argsh)
      if (( test_minify )); then
        argsh::main lint argsh.min.sh
      else
        argsh::main lint libraries
      fi
      ;;
    builtin)  lint::builtin ;;
    minifier) lint::minifier ;;
    shdoc)    lint::shdoc ;;
    *)
      echo "Unknown target: ${target}. Use: all, argsh, builtin, minifier, shdoc" >&2
      return 1
      ;;
  esac
}

argsh::docker() {
  local tag="latest"
  local -a args=(
    'tag|t' "Docker image tag"
  )
  :args "Build docker image for argsh" "${@}"
  docker build -t "ghcr.io/arg-sh/argsh:${tag}" -f "${PATH_BASE}/Dockerfile" "${PATH_BASE}"
}

###
### builtin (Rust native builtins)
###
_require_rust() {
  binary::exists cargo || {
    echo "Rust toolchain required. Install: https://rustup.rs"
    return 1
  } >&2
}

lint::builtin() {
  :args "Run clippy on native builtins" "${@}"
  _require_rust
  cargo clippy --release \
    --manifest-path "${PATH_BASE}/builtin/Cargo.toml" \
    -- -D warnings
}

test::builtin() {
  :args "Build and test native builtins" "${@}"
  _require_rust
  cargo build --release \
    --manifest-path "${PATH_BASE}/builtin/Cargo.toml"
  rm -f "${PATH_BIN}/argsh.so" && cp "${PATH_BASE}/builtin/target/release/libargsh.so" "${PATH_BIN}/argsh.so"
  binary::exists bats || {
    echo "bats required. Install: https://github.com/bats-core/bats-core"
    return 1
  } >&2
  ARGSH_BUILTIN_TEST=1 ARGSH_SOURCE=argsh \
    bats "${PATH_BASE}/libraries/args.bats" \
         "${PATH_BASE}/libraries/import.bats"
}

coverage::builtin() {
  :args "Generate coverage for native builtins" "${@}"
  _require_rust

  local host_triple llvm_tools cov_dir so_path
  host_triple="$(rustc -vV | awk '/host:/{print $2}')"
  llvm_tools="$(rustc --print sysroot)/lib/rustlib/${host_triple}/bin"
  cov_dir="${PATH_BASE}/builtin/target/coverage"
  so_path="${PATH_BASE}/builtin/target/release/libargsh.so"

  # Ensure llvm-tools
  [[ -x "${llvm_tools}/llvm-profdata" ]] || {
    echo "Installing llvm-tools..."
    rustup component add llvm-tools
  }

  # Build coverage-instrumented .so inside Docker (rust:1-slim-bookworm) to ensure
  # glibc compatibility with the kcov/kcov test container (also Debian bookworm).
  # Mount sources at the same absolute path so llvm-cov finds them on the host.
  # Share cargo registry cache to avoid re-downloading dependencies.
  echo "Building with coverage instrumentation (via Docker)..."
  mkdir -p "${HOME}/.cargo/registry"
  docker run --rm \
    --user "$(id -u):$(id -g)" \
    -v "${PATH_BASE}/builtin:${PATH_BASE}/builtin" \
    -v "${HOME}/.cargo/registry:/usr/local/cargo/registry" \
    -w "${PATH_BASE}/builtin" \
    rust:1-slim-bookworm \
    bash -c 'RUSTFLAGS="-C instrument-coverage" \
      CARGO_PROFILE_RELEASE_STRIP=none \
      CARGO_PROFILE_RELEASE_LTO=false \
      CARGO_PROFILE_RELEASE_PANIC=unwind \
      cargo build --release'

  rm -rf "${cov_dir}"
  mkdir -p "${cov_dir}"

  echo "Running tests (via Docker)..."
  ARGSH_BUILTIN_TEST=1 \
  ARGSH_SOURCE=argsh \
  ARGSH_BUILTIN_PATH="/workspace/builtin/target/release/libargsh.so" \
  LLVM_PROFILE_FILE="/workspace/builtin/target/coverage/coverage-%p.profraw" \
    argsh::main test libraries/args.bats libraries/import.bats

  # Merge profile data and clean up raw profiles
  "${llvm_tools}/llvm-profdata" merge -sparse \
    "${cov_dir}"/coverage-*.profraw \
    -o "${cov_dir}/coverage.profdata"
  rm -f "${cov_dir}"/coverage-*.profraw

  echo ""
  "${llvm_tools}/llvm-cov" report \
    --instr-profile="${cov_dir}/coverage.profdata" \
    "${so_path}" \
    --ignore-filename-regex='cargo/registry' \
    --ignore-filename-regex='rustup/toolchains' \
    --ignore-filename-regex='^/rustc/'

  # Export JSON and generate builtin/coverage.json
  local _cov_tmp; _cov_tmp="$(mktemp)"
  "${llvm_tools}/llvm-cov" export \
    --instr-profile="${cov_dir}/coverage.profdata" \
    "${so_path}" \
    --ignore-filename-regex='cargo/registry' \
    --ignore-filename-regex='rustup/toolchains' \
    --ignore-filename-regex='^/rustc/' \
    --summary-only > "${_cov_tmp}"

  # Count // coverage:off lines per source file → JSON map
  local _excl="{" _first=true _f _n
  while IFS= read -r _f; do
    _n=$(grep -c '// coverage:off' "${_f}" 2>/dev/null) || _n=0
    ${_first} || _excl+=","
    _excl+="$(printf '"%s":%d' "${_f}" "${_n}")"
    _first=false
  done < <(jq -r '.data[0].files[].filename' "${_cov_tmp}")
  _excl+="}"

  # Generate coverage.json with jq (excludes annotated lines from totals)
  jq --argjson excl "${_excl}" --arg date "$(date '+%Y-%m-%d %H:%M:%S')" --arg prefix "${PATH_BASE}/" '
    def fmt2: (. * 100 | round) / 100 | tostring |
      if test("[.]") then (if test("[.][0-9]$") then . + "0" else . end)
      else . + ".00" end;
    .data[0] as $d |
    ($excl | to_entries | map(.value) | add // 0) as $total_excl |
    {
      files: ([
        $d.files[] |
        .summary.lines as $s |
        ($excl[.filename] // 0) as $ex |
        ($s.count - $ex) as $adj |
        ([$s.covered, $adj] | min) as $cov |
        {
          file: (.filename | ltrimstr($prefix)),
          percent_covered: (if $adj > 0 then ($cov / $adj * 100 | fmt2) else "100.00" end),
          covered_lines: ($cov | tostring),
          total_lines: ($adj | tostring),
          excluded_lines: ($ex | tostring)
        }
      ] | sort_by(.percent_covered | tonumber) | reverse),
      percent_covered: (
        ($d.totals.lines.count - $total_excl) as $adj |
        ([$d.totals.lines.covered, $adj] | min) as $cov |
        if $adj > 0 then ($cov / $adj * 100 | fmt2) else "100.00" end
      ),
      covered_lines: ([$d.totals.lines.covered, ($d.totals.lines.count - $total_excl)] | min),
      total_lines: ($d.totals.lines.count - $total_excl),
      excluded_lines: $total_excl,
      percent_low: 25,
      percent_high: 75,
      command: "bats+llvm-cov",
      date: $date
    }
  ' "${_cov_tmp}" > "${PATH_BASE}/builtin/coverage.json"
  rm -f "${_cov_tmp}"

  local pct
  pct="$(jq -r '.percent_covered' "${PATH_BASE}/builtin/coverage.json")"
  echo ""
  echo "Coverage: ${pct}% of required ${MIN_COVERAGE}%"

  # Clean up coverage artifacts (profraw files from instrumented .so in main process)
  rm -rf "${cov_dir}"
  find "${PATH_BASE}" -maxdepth 2 -name '*.profraw' -delete 2>/dev/null || true

  # Rebuild without instrumentation for normal use
  echo "Rebuilding without instrumentation..."
  cargo build --release \
    --manifest-path "${PATH_BASE}/builtin/Cargo.toml"
  rm -f "${PATH_BIN}/argsh.so" && cp "${so_path}" "${PATH_BIN}/argsh.so"
}

###
### shdoc (Rust documentation generator)
###
lint::shdoc() {
  :args "Run clippy on shdoc" "${@}"
  _require_rust
  cargo clippy \
    --manifest-path "${PATH_BASE}/shdoc/Cargo.toml" \
    -- -D warnings
}

test::shdoc() {
  :args "Build and test shdoc" "${@}"
  _require_rust
  cargo test \
    --manifest-path "${PATH_BASE}/shdoc/Cargo.toml"
}

build::shdoc() {
  :args "Build shdoc binary" "${@}"
  _require_rust
  cargo build --release \
    --manifest-path "${PATH_BASE}/shdoc/Cargo.toml"
  rm -f "${PATH_BIN}/shdoc" && cp "${PATH_BASE}/shdoc/target/release/shdoc" "${PATH_BIN}/shdoc"
  echo "Built: ${PATH_BIN}/shdoc"
}

# shellcheck disable=SC2016
coverage::shdoc() {
  :args "Generate coverage for shdoc" "${@}"
  _require_rust

  local host_triple llvm_tools cov_dir
  host_triple="$(rustc -vV | awk '/host:/{print $2}')"
  llvm_tools="$(rustc --print sysroot)/lib/rustlib/${host_triple}/bin"
  cov_dir="${PATH_BASE}/shdoc/target/coverage"

  # Ensure llvm-tools
  [[ -x "${llvm_tools}/llvm-profdata" ]] || {
    echo "Installing llvm-tools..."
    rustup component add llvm-tools
  }

  # Build test binaries with coverage and capture their paths
  echo "Building tests with coverage instrumentation..."
  local -a bins=()
  while IFS= read -r line; do
    bins+=("${line}")
  done < <(
    RUSTFLAGS="-C instrument-coverage" \
    cargo test --no-run --message-format=json \
      --manifest-path "${PATH_BASE}/shdoc/Cargo.toml" 2>/dev/null |
    jq -r 'select(.executable) | .executable'
  )

  rm -rf "${cov_dir}"
  mkdir -p "${cov_dir}"

  # Run tests with coverage
  echo "Running tests..."
  RUSTFLAGS="-C instrument-coverage" \
  LLVM_PROFILE_FILE="${cov_dir}/coverage-%p.profraw" \
    cargo test --manifest-path "${PATH_BASE}/shdoc/Cargo.toml"

  # Merge profile data
  "${llvm_tools}/llvm-profdata" merge -sparse \
    "${cov_dir}"/coverage-*.profraw \
    -o "${cov_dir}/coverage.profdata"
  rm -f "${cov_dir}"/coverage-*.profraw

  # Build --object args for llvm-cov (multiple test binaries)
  local -a obj_args=()
  local bin
  for bin in "${bins[@]}"; do
    obj_args+=("--object" "${bin}")
  done

  echo ""
  "${llvm_tools}/llvm-cov" report \
    --instr-profile="${cov_dir}/coverage.profdata" \
    "${obj_args[@]}" \
    --ignore-filename-regex='\.cargo/registry' \
    --ignore-filename-regex='\.rustup/toolchains' \
    --ignore-filename-regex='^/rustc/'

  # Export JSON and generate shdoc/coverage.json
  local _cov_tmp; _cov_tmp="$(mktemp)"
  "${llvm_tools}/llvm-cov" export \
    --instr-profile="${cov_dir}/coverage.profdata" \
    "${obj_args[@]}" \
    --ignore-filename-regex='\.cargo/registry' \
    --ignore-filename-regex='\.rustup/toolchains' \
    --ignore-filename-regex='^/rustc/' \
    --summary-only > "${_cov_tmp}"

  # Count // coverage:off lines per source file → JSON map
  local _excl="{" _first=true _f _n
  while IFS= read -r _f; do
    _n=$(grep -c '// coverage:off' "${_f}" 2>/dev/null) || _n=0
    ${_first} || _excl+=","
    _excl+="$(printf '"%s":%d' "${_f}" "${_n}")"
    _first=false
  done < <(jq -r '.data[0].files[].filename' "${_cov_tmp}")
  _excl+="}"

  # Generate coverage.json with jq (excludes annotated lines from totals)
  jq --argjson excl "${_excl}" --arg date "$(date '+%Y-%m-%d %H:%M:%S')" --arg prefix "${PATH_BASE}/" '
    def fmt2: (. * 100 | round) / 100 | tostring |
      if test("[.]") then (if test("[.][0-9]$") then . + "0" else . end)
      else . + ".00" end;
    .data[0] as $d |
    ($excl | to_entries | map(.value) | add // 0) as $total_excl |
    {
      files: ([
        $d.files[] |
        .summary.lines as $s |
        ($excl[.filename] // 0) as $ex |
        ($s.count - $ex) as $adj |
        ([$s.covered, $adj] | min) as $cov |
        {
          file: (.filename | ltrimstr($prefix)),
          percent_covered: (if $adj > 0 then ($cov / $adj * 100 | fmt2) else "100.00" end),
          covered_lines: ($cov | tostring),
          total_lines: ($adj | tostring),
          excluded_lines: ($ex | tostring)
        }
      ] | sort_by(.percent_covered | tonumber) | reverse),
      percent_covered: (
        ($d.totals.lines.count - $total_excl) as $adj |
        ([$d.totals.lines.covered, $adj] | min) as $cov |
        if $adj > 0 then ($cov / $adj * 100 | fmt2) else "100.00" end
      ),
      covered_lines: ([$d.totals.lines.covered, ($d.totals.lines.count - $total_excl)] | min),
      total_lines: ($d.totals.lines.count - $total_excl),
      excluded_lines: $total_excl,
      percent_low: 25,
      percent_high: 75,
      command: "cargo-test+llvm-cov",
      date: $date
    }
  ' "${_cov_tmp}" > "${PATH_BASE}/shdoc/coverage.json"
  rm -f "${_cov_tmp}"

  local pct
  pct="$(jq -r '.percent_covered' "${PATH_BASE}/shdoc/coverage.json")"
  echo ""
  echo "Coverage: ${pct}% of required ${MIN_COVERAGE}%"

  # Clean up coverage artifacts
  rm -rf "${cov_dir}"
  find "${PATH_BASE}/shdoc" -maxdepth 2 -name '*.profraw' -delete 2>/dev/null || true
}

###
### minifier (Rust bash minifier)
###
lint::minifier() {
  :args "Run clippy on minifier" "${@}"
  _require_rust
  cargo clippy \
    --manifest-path "${PATH_BASE}/minifier/Cargo.toml" \
    -- -D warnings
}

test::minifier() {
  :args "Build and test minifier" "${@}"
  _require_rust
  cargo test \
    --manifest-path "${PATH_BASE}/minifier/Cargo.toml"
}

# shellcheck disable=SC2016
coverage::minifier() {
  :args "Generate coverage for minifier" "${@}"
  _require_rust

  local host_triple llvm_tools cov_dir
  host_triple="$(rustc -vV | awk '/host:/{print $2}')"
  llvm_tools="$(rustc --print sysroot)/lib/rustlib/${host_triple}/bin"
  cov_dir="${PATH_BASE}/minifier/target/coverage"

  # Ensure llvm-tools
  [[ -x "${llvm_tools}/llvm-profdata" ]] || {
    echo "Installing llvm-tools..."
    rustup component add llvm-tools
  }

  # Build test binaries with coverage and capture their paths
  echo "Building tests with coverage instrumentation..."
  local -a bins=()
  while IFS= read -r line; do
    bins+=("${line}")
  done < <(
    RUSTFLAGS="-C instrument-coverage" \
    cargo test --no-run --message-format=json \
      --manifest-path "${PATH_BASE}/minifier/Cargo.toml" 2>/dev/null |
    jq -r 'select(.executable) | .executable'
  )

  rm -rf "${cov_dir}"
  mkdir -p "${cov_dir}"

  # Run tests with coverage
  echo "Running tests..."
  RUSTFLAGS="-C instrument-coverage" \
  LLVM_PROFILE_FILE="${cov_dir}/coverage-%p.profraw" \
    cargo test --manifest-path "${PATH_BASE}/minifier/Cargo.toml"

  # Merge profile data
  "${llvm_tools}/llvm-profdata" merge -sparse \
    "${cov_dir}"/coverage-*.profraw \
    -o "${cov_dir}/coverage.profdata"
  rm -f "${cov_dir}"/coverage-*.profraw

  # Build --object args for llvm-cov (multiple test binaries)
  local -a obj_args=()
  local bin
  for bin in "${bins[@]}"; do
    obj_args+=("--object" "${bin}")
  done

  echo ""
  "${llvm_tools}/llvm-cov" report \
    --instr-profile="${cov_dir}/coverage.profdata" \
    "${obj_args[@]}" \
    --ignore-filename-regex='\.cargo/registry' \
    --ignore-filename-regex='\.rustup/toolchains' \
    --ignore-filename-regex='^/rustc/'

  # Export JSON and generate minifier/coverage.json
  local _cov_tmp; _cov_tmp="$(mktemp)"
  "${llvm_tools}/llvm-cov" export \
    --instr-profile="${cov_dir}/coverage.profdata" \
    "${obj_args[@]}" \
    --ignore-filename-regex='\.cargo/registry' \
    --ignore-filename-regex='\.rustup/toolchains' \
    --ignore-filename-regex='^/rustc/' \
    --summary-only > "${_cov_tmp}"

  # Count // coverage:off lines per source file → JSON map
  local _excl="{" _first=true _f _n
  while IFS= read -r _f; do
    _n=$(grep -c '// coverage:off' "${_f}" 2>/dev/null) || _n=0
    ${_first} || _excl+=","
    _excl+="$(printf '"%s":%d' "${_f}" "${_n}")"
    _first=false
  done < <(jq -r '.data[0].files[].filename' "${_cov_tmp}")
  _excl+="}"

  # Generate coverage.json with jq (excludes annotated lines from totals)
  jq --argjson excl "${_excl}" --arg date "$(date '+%Y-%m-%d %H:%M:%S')" --arg prefix "${PATH_BASE}/" '
    def fmt2: (. * 100 | round) / 100 | tostring |
      if test("[.]") then (if test("[.][0-9]$") then . + "0" else . end)
      else . + ".00" end;
    .data[0] as $d |
    ($excl | to_entries | map(.value) | add // 0) as $total_excl |
    {
      files: ([
        $d.files[] |
        .summary.lines as $s |
        ($excl[.filename] // 0) as $ex |
        ($s.count - $ex) as $adj |
        ([$s.covered, $adj] | min) as $cov |
        {
          file: (.filename | ltrimstr($prefix)),
          percent_covered: (if $adj > 0 then ($cov / $adj * 100 | fmt2) else "100.00" end),
          covered_lines: ($cov | tostring),
          total_lines: ($adj | tostring),
          excluded_lines: ($ex | tostring)
        }
      ] | sort_by(.percent_covered | tonumber) | reverse),
      percent_covered: (
        ($d.totals.lines.count - $total_excl) as $adj |
        ([$d.totals.lines.covered, $adj] | min) as $cov |
        if $adj > 0 then ($cov / $adj * 100 | fmt2) else "100.00" end
      ),
      covered_lines: ([$d.totals.lines.covered, ($d.totals.lines.count - $total_excl)] | min),
      total_lines: ($d.totals.lines.count - $total_excl),
      excluded_lines: $total_excl,
      percent_low: 25,
      percent_high: 75,
      command: "cargo-test+llvm-cov",
      date: $date
    }
  ' "${_cov_tmp}" > "${PATH_BASE}/minifier/coverage.json"
  rm -f "${_cov_tmp}"

  local pct
  pct="$(jq -r '.percent_covered' "${PATH_BASE}/minifier/coverage.json")"
  echo ""
  echo "Coverage: ${pct}% of required ${MIN_COVERAGE}%"

  # Clean up coverage artifacts
  rm -rf "${cov_dir}"
  find "${PATH_BASE}/minifier" -maxdepth 2 -name '*.profraw' -delete 2>/dev/null || true
}

###
### build
###
build::builtin() {
  :args "Build native builtins (.so)" "${@}"
  _require_rust
  cargo build --release \
    --manifest-path "${PATH_BASE}/builtin/Cargo.toml"
  rm -f "${PATH_BIN}/argsh.so" && cp "${PATH_BASE}/builtin/target/release/libargsh.so" "${PATH_BIN}/argsh.so"
  echo "Built: ${PATH_BIN}/argsh.so"
}

build::minifier() {
  :args "Build minifier binary" "${@}"
  _require_rust
  cargo build --release \
    --manifest-path "${PATH_BASE}/minifier/Cargo.toml"
  rm -f "${PATH_BIN}/minifier" && cp "${PATH_BASE}/minifier/target/release/minifier" "${PATH_BIN}/minifier"
  echo "Built: ${PATH_BIN}/minifier"
}

_build() {
  local target="all"
  local -a args=(
    'target' "Build target (all, builtin, minifier, shdoc)"
  )
  :args "Build release binaries" "${@}"

  case "${target}" in
    all)
      build::builtin
      build::minifier
      build::shdoc
      ;;
    builtin)  build::builtin ;;
    minifier) build::minifier ;;
    shdoc)    build::shdoc ;;
    *)
      echo "Unknown target: ${target}. Use: all, builtin, minifier, shdoc" >&2
      return 1
      ;;
  esac
}

###
### coverage dispatcher
###
_coverage() {
  local target="all"
  local -a args=(
    'target' "Coverage target (all, builtin, minifier, shdoc)"
  )
  :args "Generate code coverage reports" "${@}"

  case "${target}" in
    all)
      coverage::builtin
      coverage::minifier
      coverage::shdoc
      ;;
    builtin)  coverage::builtin ;;
    minifier) coverage::minifier ;;
    shdoc)    coverage::shdoc ;;
    *)
      echo "Unknown target: ${target}. Use: all, builtin, minifier, shdoc" >&2
      return 1
      ;;
  esac
}

###
### ci (minify + lint + coverage + commit)
###
_ci() {
  local message="regenerate files"
  local -a args=(
    'message|m' "Commit message"
  )
  :args "Minify, lint, coverage, then commit regenerated files" "${@}"

  if [[ -n "$(git -C "${PATH_BASE}" status --porcelain)" ]]; then
    echo "Warning: repository has uncommitted changes." >&2
    git -C "${PATH_BASE}" status --short >&2
    echo >&2
    if [[ -t 0 ]]; then
      read -rp "Continue anyway? [y/N] " answer
      [[ "${answer}" =~ ^[Yy] ]] || { echo "Aborted." >&2; return 1; }
    else
      echo "Non-interactive mode — aborting. Commit or stash changes first." >&2
      return 1
    fi
  fi

  minify::argsh
  _lint
  _lint -m
  _coverage

  git -C "${PATH_BASE}" add -A
  git -C "${PATH_BASE}" commit -m "${message}" --no-gpg-sign
}

###
### e2e (manual integration tests using claude CLI)
###
_e2e() {
  local script model budget
  # shellcheck disable=SC2016
  local prompt='You have MCP tools from "test-app". Call the serve tool with verbose set to true. Reply with ONLY the raw tool output.'
  local -a args=(
    'script|s'      "Script to test (default: built-in fixture)"
    'model|m'       "Claude model (default: haiku)"
    'budget|b'      "Max budget in USD (default: 0.05)"
    'prompt'        "Custom prompt for Claude"
  )
  :args "E2E MCP test: validates tool discovery + invocation via Claude CLI" "${@}"

  : "${model:=haiku}"
  : "${budget:=0.05}"
  : "${script:="${PATH_BASE}/libraries/fixtures/args/mcp_test.sh"}"

  binary::exists claude || {
    echo "claude CLI required. Install: https://docs.anthropic.com/en/docs/claude-code"
    return 1
  } >&2
  script="$(cd "$(dirname "${script}")" && pwd)/$(basename "${script}")"
  [[ -x "${script}" ]] || { echo "Script not executable: ${script}" >&2; return 1; }

  # Ensure builtin .so
  [[ -f "${PATH_BIN}/argsh.so" ]] || {
    local release="${PATH_BASE}/builtin/target/release/libargsh.so"
    [[ -f "${release}" ]] || { echo "builtin .so not found — run: argsh build builtin" >&2; return 1; }
    cp "${release}" "${PATH_BIN}/argsh.so"
  }

  echo "Pre-flight: testing ${script} in CLI mode..."
  local out
  out=$("${script}" --help 2>&1) || { echo "Script --help failed" >&2; return 1; }
  echo "  OK — help text works"

  # Build MCP config (JSON-escape the script path)
  local mcp_config escaped_script
  escaped_script="${script//\\/\\\\}"
  escaped_script="${escaped_script//\"/\\\"}"
  mcp_config=$(printf '{"mcpServers":{"test-app":{"type":"stdio","command":"%s","args":["mcp"]}}}' "${escaped_script}")

  echo ""
  echo "Running: claude --print --model ${model} --max-budget-usd ${budget}"
  echo "MCP server: ${script} mcp"
  echo ""

  local result
  result=$(claude \
    --print \
    --model "${model}" \
    --max-budget-usd "${budget}" \
    --mcp-config "${mcp_config}" \
    --allowedTools "mcp__test-app__*" \
    --permission-mode "bypassPermissions" \
    --no-session-persistence \
    -p "${prompt}" \
    2>/dev/null) || { echo "claude CLI failed" >&2; return 1; }

  echo "Claude response:"
  echo "${result}"
  echo "---"

  local pass=0 total=2
  if echo "${result}" | grep -qi "serving"; then echo "PASS: contains 'serving'"; ((++pass)); else echo "FAIL: missing 'serving'"; fi
  if echo "${result}" | grep -qi "verbose"; then echo "PASS: contains 'verbose'"; ((++pass)); else echo "FAIL: missing 'verbose'"; fi

  echo ""
  echo "Results: ${pass}/${total}"
  [[ "${pass}" -eq "${total}" ]] || return 1
}

###
### main
###
argsh::main() {
  local tty=""
  local _image="${ARGSH_DOCKER_IMAGE:-ghcr.io/arg-sh/argsh:latest}"

  if [[ -z "${ARGSH_DOCKER_IMAGE:-}" ]]; then
    argsh::docker &>/dev/null || {
      echo "Docker build failed. Run 'argsh docker' to see errors." >&2
      return 1
    }
  fi

  [[ ! -t 1 ]] || tty="-it"
  # shellcheck disable=SC2046
  docker run --rm ${tty} $(docker::user) -w /workspace \
    -e "BATS_LOAD" \
    -e "ARGSH_SOURCE" \
    -e "ARGSH_BUILTIN_TEST" \
    ${ARGSH_BUILTIN_PATH:+-e "ARGSH_BUILTIN_PATH=${ARGSH_BUILTIN_PATH}"} \
    -e "LLVM_PROFILE_FILE" \
    -e "GIT_COMMIT_SHA=$(git rev-parse HEAD 2>/dev/null || :)" \
    -e "GIT_VERSION=$(git describe --tags --dirty 2>/dev/null || :)" \
    "${_image}" "${@}"
}

_main() {
  if [[ "${BASH_SOURCE[-1]}" != "${1:-}" && -f "${1:-}" ]]; then
    ARGSH_SOURCE="${1}"; shift
    # shellcheck source=/dev/null
    . "${ARGSH_SOURCE}"
    exit 0
  fi

  binary::exists docker || {
    echo "This script requires Docker to be installed"
    return 1
  } >&2

  local -a usage
  usage=(
    -                           "Commands"
    'ci|all:-_ci'               "Minify, lint, coverage, commit regenerated files"
    'build:-_build'             "Build release binaries [all|builtin|minifier]"
    'lint:-_lint'               "Run linters [all|argsh|builtin|minifier]"
    'test:-_test'               "Run tests [all|argsh|builtin|minifier]"
    'coverage:-_coverage'       "Generate coverage [all|builtin|minifier]"
    'minify:-minify::argsh'     "Minify argsh libraries"
    -                           "Documentation"
    'generate:-generate::docs'  "Generate library documentation"
    'docs-lint:-lint::docs'     "Run documentation linters"
    'docs-test:-test::docs'     "Run documentation tests"
    'vale:-lint::vale'          "Run vale"
    -                           "Integration"
    'e2e:-_e2e'                 "E2E MCP test via Claude CLI [--script ./app.sh]"
    -                           "Additional commands"
    'docker:-argsh::docker'     "Build docker image"
  )
  :usage "Helper to manage this project" "${@}"
  "${usage[@]}"
}

[[ "${BASH_SOURCE[0]}" != "${0}" ]] || _main "${@}"