#!/usr/bin/env bash
# shellcheck disable=SC1091 disable=SC2034 disable=SC2046 disable=SC2120
set -euo pipefail

: "${PATH_BASE:="$(git rev-parse --show-toplevel)"}"
: "${MIN_COVERAGE:="70"}"
:

source "${PATH_BASE}/libraries/args.sh"
source "${PATH_BASE}/libraries/args.utils.sh"
source "${PATH_BASE}/libraries/binary.sh"
source "${PATH_BASE}/libraries/docker.sh"
# trap error::stacktrace EXIT

###
### docs
###
test::docs() {
  :args "Run tests for the documentation" "${@}"
  docker run --rm $(docker::user) node:21-alpine sh -c "
    cd /workspace/www
    [ -d node_modules ] || yarn --silent --frozen-lockfile
    yarn build
  "
}

lint::docs() {
  :args "Run linters for the documentation" "${@}"
  docker run --rm $(docker::user) node:21-alpine sh -c "
    cd /workspace/www
    [ -d node_modules ] || yarn --silent --frozen-lockfile
    yarn lint:content
    yarn lint
  "
}

lint::vale() {
  :args "Run vale for the documentation" "${@}"
  local alert_level="${vale?"need to specify alert level"}"
  binary::exists docker || exit 1
  docker run --rm $(docker::user) jdkato/vale:latest sh -c "
    cd /workspace/www/vale
    ./run-vale.sh docs content \"${alert_level}\"
  "
}

###
### argsh
###
generate::docs() {
  :args "Generate library documentation for docs" "${@}"
  argsh::main docs libraries www/apps/docs/content/libraries
}

minify::argsh() {
  :args "Minify argsh libraries" "${@}"
  argsh::main minify libraries -t argsh.min.tmpl -o argsh.min.sh
}

coverage::argsh() {
  :args "Generate coverage report for argsh (bash + builtin)" "${@}"
  argsh::main coverage libraries -o coverage --min "${MIN_COVERAGE}"
  # Also generate builtin coverage if Rust toolchain is available
  if binary::exists cargo; then
    echo ""
    echo "── Builtin (Rust) coverage ──"
    coverage::builtin
  fi
}

test::argsh() {
  local test_minify
  local -a args=(
    'test-minify|m:+' "Run tests for argsh.min.sh"
  )
  :args "Run tests for the arg.sh library" "${@}"
  ! (( test_minify )) || {
    BATS_LOAD="argsh.min.sh"
    export BATS_LOAD
  }
  argsh::main test libraries .docker/test
}

lint::argsh() {
  local test_minify
  local -a args=(
    'test-minify|m:+' "Run tests for argsh.min.sh"
  )
  :args "Run linters for the arg.sh library" "${@}"
  if (( test_minify )); then
    argsh::main lint argsh.min.sh
  else
    argsh::main lint libraries
  fi
}

argsh::docker() {
  local tag="latest"
  local -a args=(
    'tag|t' "Docker image tag"
  )
  :args "Build docker image for argsh" "${@}"
  docker build -t "ghcr.io/arg-sh/argsh:${tag}" -f "${PATH_BASE}/Dockerfile" "${PATH_BASE}"
}

###
### builtin (Rust native builtins)
###
_require_rust() {
  binary::exists cargo || {
    echo "Rust toolchain required. Install: https://rustup.rs"
    return 1
  } >&2
}

lint::builtin() {
  :args "Run clippy on native builtins" "${@}"
  _require_rust
  cargo clippy --release \
    --manifest-path "${PATH_BASE}/builtin/Cargo.toml" \
    -- -D warnings
}

test::builtin() {
  :args "Build and test native builtins" "${@}"
  _require_rust
  cargo build --release \
    --manifest-path "${PATH_BASE}/builtin/Cargo.toml"
  rm -f "${PATH_BIN}/argsh.so" && cp "${PATH_BASE}/builtin/target/release/libargsh.so" "${PATH_BIN}/argsh.so"
  binary::exists bats || {
    echo "bats required. Install: https://github.com/bats-core/bats-core"
    return 1
  } >&2
  ARGSH_BUILTIN_TEST=1 ARGSH_SOURCE=argsh \
    bats "${PATH_BASE}/libraries/args.bats" \
         "${PATH_BASE}/libraries/import.bats"
}

coverage::builtin() {
  :args "Generate coverage for native builtins" "${@}"
  _require_rust
  binary::exists bats || {
    echo "bats required. Install: https://github.com/bats-core/bats-core"
    return 1
  } >&2

  local host_triple llvm_tools cov_dir so_path
  host_triple="$(rustc -vV | awk '/host:/{print $2}')"
  llvm_tools="$(rustc --print sysroot)/lib/rustlib/${host_triple}/bin"
  cov_dir="${PATH_BASE}/builtin/target/coverage"
  so_path="${PATH_BASE}/builtin/target/release/libargsh.so"

  # Ensure llvm-tools
  [[ -x "${llvm_tools}/llvm-profdata" ]] || {
    echo "Installing llvm-tools..."
    rustup component add llvm-tools
  }

  # Build with coverage instrumentation (override release profile settings that break coverage)
  echo "Building with coverage instrumentation..."
  RUSTFLAGS="-C instrument-coverage" \
  CARGO_PROFILE_RELEASE_STRIP="none" \
  CARGO_PROFILE_RELEASE_LTO="false" \
  CARGO_PROFILE_RELEASE_PANIC="unwind" \
    cargo build --release \
      --manifest-path "${PATH_BASE}/builtin/Cargo.toml"

  rm -f "${PATH_BIN}/argsh.so" && cp "${so_path}" "${PATH_BIN}/argsh.so"
  rm -rf "${cov_dir}"
  mkdir -p "${cov_dir}"

  echo "Running tests..."
  LLVM_PROFILE_FILE="${cov_dir}/coverage-%p-%m.profraw" \
  ARGSH_BUILTIN_TEST=1 ARGSH_SOURCE=argsh \
    bats "${PATH_BASE}/libraries/args.bats" \
         "${PATH_BASE}/libraries/import.bats"

  # Merge profile data
  "${llvm_tools}/llvm-profdata" merge -sparse \
    "${cov_dir}"/coverage-*.profraw \
    -o "${cov_dir}/coverage.profdata"

  echo ""
  "${llvm_tools}/llvm-cov" report \
    --instr-profile="${cov_dir}/coverage.profdata" \
    "${so_path}" \
    --ignore-filename-regex='\.cargo/registry'

  # Export JSON and generate builtin/coverage.json
  local _cov_tmp; _cov_tmp="$(mktemp)"
  "${llvm_tools}/llvm-cov" export \
    --instr-profile="${cov_dir}/coverage.profdata" \
    "${so_path}" \
    --ignore-filename-regex='\.cargo/registry' \
    --summary-only > "${_cov_tmp}"

  # Count // coverage:off lines per source file → JSON map
  local _excl="{" _first=true _f _n
  while IFS= read -r _f; do
    _n=$(grep -c '// coverage:off' "${_f}" 2>/dev/null) || _n=0
    ${_first} || _excl+=","
    _excl+="$(printf '"%s":%d' "${_f}" "${_n}")"
    _first=false
  done < <(jq -r '.data[0].files[].filename' "${_cov_tmp}")
  _excl+="}"

  # Generate coverage.json with jq (excludes annotated lines from totals)
  jq --argjson excl "${_excl}" --arg date "$(date '+%Y-%m-%d %H:%M:%S')" '
    def fmt2: (. * 100 | round) / 100 | tostring |
      if test("[.]") then (if test("[.][0-9]$") then . + "0" else . end)
      else . + ".00" end;
    .data[0] as $d |
    ($excl | to_entries | map(.value) | add // 0) as $total_excl |
    {
      files: ([
        $d.files[] |
        .summary.lines as $s |
        ($excl[.filename] // 0) as $ex |
        ($s.count - $ex) as $adj |
        {
          file: .filename,
          percent_covered: (if $adj > 0 then ($s.covered / $adj * 100 | fmt2) else "100.00" end),
          covered_lines: ($s.covered | tostring),
          total_lines: ($adj | tostring),
          excluded_lines: ($ex | tostring)
        }
      ] | sort_by(.percent_covered | tonumber) | reverse),
      percent_covered: (
        ($d.totals.lines.count - $total_excl) as $adj |
        if $adj > 0 then ($d.totals.lines.covered / $adj * 100 | fmt2) else "100.00" end
      ),
      covered_lines: $d.totals.lines.covered,
      total_lines: ($d.totals.lines.count - $total_excl),
      excluded_lines: $total_excl,
      percent_low: 25,
      percent_high: 75,
      command: "bats+llvm-cov",
      date: $date
    }
  ' "${_cov_tmp}" > "${PATH_BASE}/builtin/coverage.json"
  rm -f "${_cov_tmp}"

  local pct
  pct="$(jq -r '.percent_covered' "${PATH_BASE}/builtin/coverage.json")"
  echo ""
  echo "Coverage: ${pct}% of required ${MIN_COVERAGE}%"

  # Rebuild without instrumentation for normal use
  echo "Rebuilding without instrumentation..."
  cargo build --release \
    --manifest-path "${PATH_BASE}/builtin/Cargo.toml"
  rm -f "${PATH_BIN}/argsh.so" && cp "${so_path}" "${PATH_BIN}/argsh.so"
}

###
### main
###
argsh::main() {
  local tty=""
  argsh::docker &>/dev/null

  [[ ! -t 1 ]] || tty="-it"
  # shellcheck disable=SC2046
  docker run --rm ${tty} $(docker::user) -w /workspace \
    -e "BATS_LOAD" \
    -e "ARGSH_SOURCE" \
    -e "GIT_COMMIT_SHA=$(git rev-parse HEAD 2>/dev/null || :)" \
    -e "GIT_VERSION=$(git describe --tags --dirty 2>/dev/null || :)" \
    ghcr.io/arg-sh/argsh:latest "${@}" 
}

_main() {
  if [[ "${BASH_SOURCE[-1]}" != "${1:-}" && -f "${1:-}" ]]; then
    ARGSH_SOURCE="${1}"; shift
    # shellcheck source=/dev/null
    . "${ARGSH_SOURCE}"
    exit 0
  fi

  binary::exists docker || {
    echo "This script requires Docker to be installed"
    return 1
  } >&2

  local -a usage
  usage=(
    -                           "Commands argsh"
    'coverage:-coverage::argsh' "Generate coverage"
    'lint:-lint::argsh'         "Run linters"
    'test:-test::argsh'         "Run tests"
    'minify:-minify::argsh'     "Minify argsh libraries"
    -                           "Commands documentation"
    'generate:-generate::docs'  "Generate argsh library documentation"
    'docs-lint:-lint::docs'     "Run linters"
    'docs-test:-test::docs'     "Run tests"
    'vale:-lint::vale'          "Run vale tests"
    -                           "Commands builtin (Rust)"
    'builtin-lint:-lint::builtin'         "Run clippy"
    'builtin-test:-test::builtin'         "Build and test"
    'builtin-coverage:-coverage::builtin' "Generate coverage"
    -                           "Additional commands"
    'docker:-argsh::docker'     "Build docker image"
  )
  :usage "Helper to manage this project" "${@}"
  "${usage[@]}"
}

[[ "${BASH_SOURCE[0]}" != "${0}" ]] || _main "${@}"